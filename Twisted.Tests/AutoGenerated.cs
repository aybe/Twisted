using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Twisted.Extensions;
using Twisted.IO;
using Twisted.PC;
using Twisted.PS.V2;

namespace Twisted.Tests;

public static class AutoGenerated
{
    public static void Test(TestContext context, string path)
    {
        using var stream = new BinaryStream(new MemoryStream(File.ReadAllBytes(path)));

        // print file information

        var info = new FileInfo(path);
        context.WriteLine($"File name: {info.Name}");
        context.WriteLine($"File size: {info.Length}");

        // read file

        TreeNode treeNode;

        var extension = Path.GetExtension(path).ToUpperInvariant();

        switch (extension)
        {
            case ".DMD":
                treeNode = new DMD(new BinaryReader(stream));
                break;
            case ".DPC":
                treeNode = DPCTester.Test(context, stream);
                break;
            default:
                throw new NotSupportedException(extension);
        }

        // check that node lengths are valid

        treeNode.TraverseDFS(s =>
        {
            switch (s)
            {
                case DMDNode dmdNode:
                    Assert.IsTrue(dmdNode.Length != default, $"Zero length for {dmdNode.GetType().Name} @ {dmdNode.Position}");
                    break;
                case DPCNode dpcNode:
                    Assert.IsTrue(dpcNode.Length != default, $"Zero length for {dpcNode.GetType().Name} @ {dpcNode.Position}");
                    break;
                default:
                    throw new NotSupportedException();
            }
        });

        // print visited, ignored, depth, count

        int count = 0, depth = 0;

        treeNode.TraverseDFS(node =>
        {
            count += 1;
            depth =  Math.Max(depth, node.Depth);
        });

        context.WriteLine();

        var visited = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Visited).ToArray();
        var ignored = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Ignored).ToArray();

        var visitedSum = visited.Sum(s => s.Length);
        var ignoredSum = ignored.Sum(s => s.Length);
        var visitedPct = (double)visitedSum / stream.Length;
        var ignoredPct = (double)ignoredSum / stream.Length;

        context.WriteLine($"Regions visited: {visited.Length} regions, {visitedPct:P3}, {visitedSum:N0} bytes");
        context.WriteLine($"Regions ignored: {ignored.Length} regions, {ignoredPct:P3}, {ignoredSum:N0} bytes");
        context.WriteLine();

        context.WriteLine($"Tree depth: {depth}");
        context.WriteLine($"Tree nodes: {count}");
        context.WriteLine();

        // print tree

        context.WriteLine(treeNode.Print());
        context.WriteLine();

        // print nodes by position

        var pairs1 = new List<KeyValuePair<long, TreeNode>>();
        var pairs2 = pairs1;

        treeNode.TraverseDFS(s =>
        {
            switch (s)
            {
                case DMDNode node:
                    pairs2.Add(new KeyValuePair<long, TreeNode>(node.Position, node));
                    break;
                case DPCNode node:
                    pairs2.Add(new KeyValuePair<long, TreeNode>(node.Position, node));
                    break;
            }
        });

        pairs1 = pairs1.OrderBy(s => s.Key).ToList();

        context.WriteLine($"Nodes by position: {pairs1.Count}");

        foreach (var (key, value) in pairs1)
        {
            context.WriteLine($"{key,-6} {value.GetType().Name}");
        }

        context.WriteLine();

        // print regions in detail

        context.WriteLine($"Regions visited: {visited.Length}");

        foreach (var region in visited)
        {
            context.WriteLine(region);
        }

        context.WriteLine();

        context.WriteLine($"Regions ignored: {ignored.Length}");

        foreach (var region in ignored)
        {
            var node = pairs1.Last(s => s.Key < region.Position).Value;
            
            context.WriteLine($"{region}, {node}");

            // some extra checks

            if (node is DMDNode0010 node0010 && (node0010.NodeType & 0xFFFF) != 0)
            {
                Assert.AreEqual(8, region.Length);
            }

            if (node is DMDNode00FF node00FF && (node00FF.Flags & 0x80) != 0)
            {
                Assert.AreEqual(16, region.Length);
            }
        }

        context.WriteLine();

        // try find out why 00FF may either be 44 or 76 bytes

        var nodes00FF = new List<DMDNode00FF>();

        treeNode.TraverseDFS(s =>
        {
            if (s is DMDNode00FF node00FF)
            {
                nodes00FF.Add(node00FF);
            }
        });

        if (nodes00FF.Any())
        {
            context.WriteLine("Structural comparison for 00FF:");

            nodes00FF = nodes00FF.OrderBy(s => s.Position).ToList();

            var tuples = new List<(long Position, byte[] Bytes)>();
            foreach (var node in nodes00FF)
            {
                stream.Position = node.Position;
                var buffer = new byte[76 + 16];
                var read   = stream.Read(buffer, 0, buffer.Length);
                Assert.AreEqual(buffer.Length, read);
                tuples.Add((node.Position, buffer));
            }

            tuples = tuples.OrderBy(s => s.Bytes, ArrayComparer<byte>.Instance).ToList();

            foreach (var (position, bytes) in tuples)
            {
                context.WriteLine($"{position,-6} {string.Join(" ", bytes.Select(s => s.ToString("X2")))}");
            }
        }

        // final extra checks

        Assert.IsTrue(visitedSum <= stream.Length, "More than 100% data visited.");
        Assert.IsTrue(ignoredSum <= stream.Length, "More than 100% data ignored.");

        Assert.AreEqual(stream.Length, visitedSum + ignoredSum, "Sum of visited and ignored mismatch stream length.");

        // Assert.IsTrue(visitedSum == stream.Length, $"Visited: {visitedPct:P3}.");
    }
}