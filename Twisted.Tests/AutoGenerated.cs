using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using JetBrains.Annotations;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Newtonsoft.Json;
using Twisted.Extensions;
using Twisted.IO;
using Twisted.PC;
using Twisted.PS.V2;

namespace Twisted.Tests;

public static class AutoGenerated
{
    public static void Test(TestContext context, string path)
    {
        using var stream = new BinaryStream(new MemoryStream(File.ReadAllBytes(path)));

        // print file information

        var info = new FileInfo(path);
        context.WriteLine($"File name: {info.Name}");
        context.WriteLine($"File size: {info.Length}");

        // read file

        TreeNode treeNode;

        var extension = Path.GetExtension(path).ToUpperInvariant();

        switch (extension)
        {
            case ".DMD":
                treeNode = new DMD(new BinaryReader(stream));
                break;
            case ".DPC":
                treeNode = DPCTester.Test(context, stream);
                break;
            default:
                throw new NotSupportedException(extension);
        }

        // check that node lengths are valid

        treeNode.TraverseDFS(s =>
        {
            switch (s)
            {
                case DMDNode dmdNode:
                    Assert.IsTrue(dmdNode.Length != default, $"Zero length for {dmdNode.GetType().Name} @ {dmdNode.Position}");
                    break;
                case DPCNode dpcNode:
                    Assert.IsTrue(dpcNode.Length != default, $"Zero length for {dpcNode.GetType().Name} @ {dpcNode.Position}");
                    break;
                default:
                    throw new NotSupportedException();
            }
        });

        // print visited, ignored, depth, count

        int count = 0, depth = 0;

        treeNode.TraverseDFS(node =>
        {
            count += 1;
            depth =  Math.Max(depth, node.Depth);
        });

        context.WriteLine();

        var visited = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Visited).ToArray();
        var ignored = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Ignored).ToArray();

        var visitedSum = visited.Sum(s => s.Length);
        var ignoredSum = ignored.Sum(s => s.Length);
        var visitedPct = (double)visitedSum / stream.Length;
        var ignoredPct = (double)ignoredSum / stream.Length;

        context.WriteLine($"Regions visited: {visited.Length} regions, {visitedPct:P3}, {visitedSum:N0} bytes");
        context.WriteLine($"Regions ignored: {ignored.Length} regions, {ignoredPct:P3}, {ignoredSum:N0} bytes");
        context.WriteLine();

        context.WriteLine($"Tree depth: {depth}");
        context.WriteLine($"Tree nodes: {count}");
        context.WriteLine();

        // print tree

        context.WriteLine(treeNode.Print());
        context.WriteLine();

        // print nodes count

        var nodesCounts = new SortedDictionary<Type, int>(Relationships.TypeComparer.Instance);

        treeNode.TraverseDFS(s =>
        {
            var type = s.GetType();

            if (!nodesCounts.ContainsKey(type))
            {
                nodesCounts.Add(type, default);
            }

            nodesCounts[type]++;
        });

        context.WriteLine("Nodes count:");

        foreach (var (key, value) in nodesCounts)
        {
            context.WriteLine($"{key.Name}: {value}");
        }

        context.WriteLine();
        
        // print nodes by position

        var pairs1 = new List<KeyValuePair<long, TreeNode>>();
        var pairs2 = pairs1;

        treeNode.TraverseDFS(s =>
        {
            switch (s)
            {
                case DMDNode node:
                    pairs2.Add(new KeyValuePair<long, TreeNode>(node.Position, node));
                    break;
                case DPCNode node:
                    pairs2.Add(new KeyValuePair<long, TreeNode>(node.Position, node));
                    break;
            }
        });

        pairs1 = pairs1.OrderBy(s => s.Key).ToList();

        if (false)
        {
            context.WriteLine($"Nodes by position: {pairs1.Count}");

            foreach (var (key, value) in pairs1)
            {
                context.WriteLine($"{key,-6} {value.GetType().Name}");
            }

            context.WriteLine();
        }

        // print regions in detail

        context.WriteLine($"Regions visited: {visited.Length}");

        foreach (var region in visited)
        {
            context.WriteLine(region);
        }

        context.WriteLine();

        context.WriteLine($"Regions ignored: {ignored.Length}");

        foreach (var region in ignored)
        {
            var node = pairs1.Last(s => s.Key < region.Position).Value;

            context.WriteLine($"{region}, {node}");

            // some extra checks

            if (node is DMDNode0010 node0010 && (node0010.NodeType & 0xFFFF) != 0)
            {
                Assert.AreEqual(8, region.Length);
            }

            if (node is DMDNode00FF node00FF && (node00FF.Flags & 0x80) != 0)
            {
                Assert.AreEqual(16, region.Length);
            }
        }

        context.WriteLine();

        // try find out why 00FF may either be 44 or 76 bytes

        if (false)
        {
            var nodes00FF = new List<DMDNode00FF>();

            treeNode.TraverseDFS(s =>
            {
                if (s is DMDNode00FF node00FF)
                {
                    nodes00FF.Add(node00FF);
                }
            });

            if (nodes00FF.Any())
            {
                context.WriteLine("Structural comparison for 00FF:");

                nodes00FF = nodes00FF.OrderBy(s => s.Position).ToList();

                var tuples = new List<(long Position, byte[] Bytes)>();

                foreach (var node in nodes00FF)
                {
                    stream.Position = node.Position;
                    var buffer = new byte[76 + 16];
                    var read   = stream.Read(buffer, 0, buffer.Length);
                    Assert.AreEqual(buffer.Length, read);
                    tuples.Add((node.Position, buffer));
                }

                tuples = tuples.OrderBy(s => s.Bytes, ArrayComparer<byte>.Instance).ToList();

                foreach (var (position, bytes) in tuples)
                {
                    context.WriteLine($"{position,-6} {string.Join(" ", bytes.Select(s => s.ToString("X2")))}");
                }
            }
        }

        context.WriteLine();

        // show what connect to what

        if (false)
        {
            const string relationshipsFile = @"C:\temp\rels.json";

            var relationships = File.Exists(relationshipsFile)
                ? JsonConvert.DeserializeObject<Relationships>(File.ReadAllText(relationshipsFile))
                : new Relationships();

            treeNode.TraverseDFS(s =>
            {
                var type = s.GetType();

                if (!relationships.Dictionary.ContainsKey(type))
                {
                    relationships.Dictionary.Add(type, new Relationships.Relationship());
                }

                var (parents, children) = relationships.Dictionary[type];

                if (s.Parent != null)
                {
                    parents.Add(s.Parent.GetType());
                }

                foreach (var node in s)
                {
                    children.Add(node.GetType());
                }
            });

            context.WriteLine("Relationships:");

            foreach (var (key, (parents, children)) in relationships.Dictionary)
            {
                context.WriteLine(key.Name);
                context.WriteLine($"\tParents: {string.Join(", ",  parents.Select(s => s.Name))}");
                context.WriteLine($"\tChildren: {string.Join(", ", children.Select(s => s.Name))}");
            }

            var json = JsonConvert.SerializeObject(relationships, Formatting.Indented);

            File.WriteAllText(relationshipsFile, json);

            context.WriteLine(json);
        }

        // final extra checks

        Assert.IsTrue(visitedSum <= stream.Length, "More than 100% data visited.");
        Assert.IsTrue(ignoredSum <= stream.Length, "More than 100% data ignored.");

        Assert.AreEqual(stream.Length, visitedSum + ignoredSum, "Sum of visited and ignored mismatch stream length.");

        // Assert.IsTrue(visitedSum == stream.Length, $"Visited: {visitedPct:P3}.");
    }

    internal class Relationships
    {
        public SortedDictionary<Type, Relationship> Dictionary { get; set; } = new(Extensions.TypeComparer.Instance);

        internal class Relationship
        {
            public SortedSet<Type> Parents { get; set; } = new(TypeComparer.Instance);

            public SortedSet<Type> Children { get; set; } = new(TypeComparer.Instance);

            public void Deconstruct(out SortedSet<Type> parents, out SortedSet<Type> children)
            {
                parents  = Parents;
                children = Children;
            }
        }

        public sealed class TypeComparer : Comparer<Type>
        {
            public static TypeComparer Instance { get; } = new();

            public override int Compare(Type? x, Type? y)
            {
                if (x == null && y == null)
                {
                    return default;
                }

                if (x == null)
                {
                    return int.MinValue;
                }

                if (y == null)
                {
                    return int.MaxValue;
                }

                var compare = string.Compare(x.FullName, y.FullName, StringComparison.Ordinal);

                return compare;
            }
        }
    }
}