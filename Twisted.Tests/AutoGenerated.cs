using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Twisted.Extensions;
using Twisted.IO;
using Twisted.PC;
using Twisted.PS;

namespace Twisted.Tests;

public static class AutoGenerated
{
    public static void Test(TestContext context, string path)
    {
        using var stream = new BinaryStream(new MemoryStream(File.ReadAllBytes(path)));

        // read the file and gather some statistics

        var extension = Path.GetExtension(path).ToUpperInvariant();

        TreeNode treeNode = extension switch
        {
            ".DMD" => new DMD(new BinaryReader(stream)),
            ".DPC" => DPCTester.Test(context, stream),
            _      => throw new NotSupportedException(extension)
        };

        var (visited, ignored, visitedSum, ignoredSum, visitedPct, ignoredPct) = GetStreamStatistics(stream);

        var nodesOrderedByPosition = GetNodesOrderedByPosition(treeNode);

        // perform some assertions

        // NOTE: scoped assertions are not covered but kept anyway so as to spot wrong structural changes in DMD implementation

        {
            if (visitedSum >= stream.Length)
                Assert.Fail("More than 100% data visited.");

            if (ignoredSum >= stream.Length)
                Assert.Fail("More than 100% data ignored.");

            if (visitedSum + ignoredSum != stream.Length)
                Assert.Fail($"Sum of visited ({visitedSum}) and ignored ({ignoredSum}) doesn't equal stream length ({stream.Length}).");
        }

        AssertNodesLength(treeNode);

        AssertNodesParents(treeNode);

        // NOTE: this will read the unreferenced vertices/normals to try achieve 100% reading rate
        AssertRegionsIgnoredAtStart(stream, treeNode, ignored, nodesOrderedByPosition);

        // NOTE: this will read unreferenced node at end to try achieve 100% reading rate
        // NOTE: this will also compare that node content matches root content
        AssertRegionsIgnoredAtEnd(stream, ignored, treeNode);

        {
            // NOTE: this must be after AssertRegionsIgnoredAtStart and AssertRegionsIgnoredAtEnd

            // assert that there are no orphan nodes

            var regions = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Ignored).ToArray();

            if (regions.Length == 0)
            {
                context.WriteLine("NOTE: 100% reading achieved but stats below don't reflect that.");
            }
            else
            {
                context.WriteLine("NOTE: 100% reading NOT achieved, the following regions haven't been read.");

                Assert.Fail(string.Join(Environment.NewLine, "Regions that haven't been read:", string.Join(Environment.NewLine, regions)));
            }

            context.WriteLine();
        }

        // print some statistics

        PrintFileInfo(context, path);

        PrintStreamRegionsBrief(context, visited, visitedPct, visitedSum, ignored, ignoredPct, ignoredSum);

        PrintTreeDepthAndNodeCount(context, treeNode);

        PrintTree(context, treeNode);

        PrintNodesCountByType(context, treeNode);

        PrintNodesByPosition(context, nodesOrderedByPosition);

        PrintStreamRegionsDetailed(context, visited, ignored, nodesOrderedByPosition);

        PrintNodesRelationships(context, treeNode);
    }

    private static void AssertRegionsIgnoredAtStart(
        Stream stream, TreeNode treeNode, BinaryStreamRegion[] ignored, List<(long Position, TreeNode Node)> nodesByPosition)
    {
        if (stream == null)
            throw new ArgumentNullException(nameof(stream));

        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        if (ignored == null)
            throw new ArgumentNullException(nameof(ignored));

        if (nodesByPosition == null)
            throw new ArgumentNullException(nameof(nodesByPosition));

        var regions = ignored[..^1];

        switch (treeNode)
        {
            case DMDNode dmdNode:
            {
                var firstChild = (DMDNode)dmdNode[0];

                foreach (var region in regions)
                {
                    Assert.IsTrue(
                        region.Position < firstChild.Position,
                        $"Ignored vertex/normal region {region} is expected to be before first DMD child {firstChild}."
                    );
                }

                var lastIgnoredRegion = ignored.Last();

                var (lastNodePosition, lastNode) = nodesByPosition.Last();

                Assert.IsTrue(
                    lastIgnoredRegion.Position > lastNodePosition,
                    $"Last ignored region {lastIgnoredRegion} is expected to be after last node {lastNode}."
                );

                break;
            }
            default:
                throw new NotSupportedException($"Unknown node type: {treeNode.GetType().Name}.");
        }

        var reader = new BinaryReader(stream);

        using (new BinaryReaderPositionScope(reader))
        {
            foreach (var region in regions)
            {
                reader.BaseStream.Position = region.Position;
                reader.ReadBytes(region.Length.ToInt32());
            }
        }
    }

    private static void AssertRegionsIgnoredAtEnd(Stream stream, BinaryStreamRegion[] ignored, TreeNode root)
    {
        if (stream == null)
            throw new ArgumentNullException(nameof(stream));

        if (ignored == null)
            throw new ArgumentNullException(nameof(ignored));

        if (root == null)
            throw new ArgumentNullException(nameof(root));

        if (root is not DMDNode)
            throw new ArgumentOutOfRangeException(nameof(root), root, $"{nameof(DMDNode)} expected.");

        var reader = new BinaryReader(stream);

        var position = ignored.Last().Position;

        DMDNode node;

        using (new BinaryReaderPositionScope(reader, position))
        {
            node = DMDNode.ReadNode(null, reader);
        }

        Assert.IsTrue(node is DMDNode0107, $"Node at EOF is expected to be {nameof(DMDNode0107)}.");

        var positions1 = root.OfType<DMDNode>().Select(s => s.Position).ToArray();
        var positions2 = node.OfType<DMDNode>().Select(s => s.Position).ToArray();

        CollectionAssert.AreEqual(positions1, positions2, "Last node children does not match root node children.");
    }

    private static void AssertNodesLength(TreeNode treeNode)
    {
        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        foreach (var node in treeNode.TraverseDfsPreOrder())
        {
            switch (node)
            {
                case DMDNode dmdNode:
                    Assert.IsTrue(dmdNode.Length != default,
                        $"Zero length for {dmdNode.GetType().Name} @ {dmdNode.Position}");

                    break;
                case DPCNode dpcNode:
                    Assert.IsTrue(dpcNode.Length != default,
                        $"Zero length for {dpcNode.GetType().Name} @ {dpcNode.Position}");

                    break;
                default:
                    throw new NotSupportedException($"Unknown node type: {node.GetType().Name}.");
            }
        }
    }

    private static void AssertNodesParents(TreeNode treeNode)
    {
        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        foreach (var node in treeNode.TraverseDfsPreOrder())
        {
            switch (node)
            {
                case DMDNode0010:
                    Assert.IsTrue(
                        node.Parent is DMDNode020X or DMDNode0B06,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode00FF:
                    Assert.IsTrue(
                        node.Parent is DMDNode0010 or DMDNode0107 or DMDNode0305 or DMDNode0903 or DMDNode0B06 or DMDNodeXXXX,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode0107:
                    Assert.IsTrue(
                        node.Parent is DMD or DMDNode0107 or DMDNode040B or DMDNode050B or DMDNode0903 or DMDNode0B06 or DMDNodeXXXX,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode020X:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNode040B or DMDNode050B,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode0305:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode040B:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNode040B or DMDNode050B or DMDNode0903 or DMDNodeXXXX,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode050B:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNode040B or DMDNode0903 or DMDNodeXXXX,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode07FF:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNode040B,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode08FF:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNode040B or DMDNode0903 or DMDNodeXXXX,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode0903:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107 or DMDNodeXXXX or DMDNode040B,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNode0B06:
                    Assert.IsTrue(
                        node.Parent is DMDNode0107,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
                case DMDNodeXXXX:
                    Assert.IsTrue(
                        node.Parent is DMDNode020X,
                        $"{node.GetType()}, Parent: {node.Parent.GetType()}"
                    );

                    break;
            }
        }
    }

    private static
        (BinaryStreamRegion[] visited, BinaryStreamRegion[] ignored, long visitedSum, long ignoredSum, double visitedPct, double ignoredPct)
        GetStreamStatistics(BinaryStream stream)
    {
        if (stream == null)
            throw new ArgumentNullException(nameof(stream));

        var visited    = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Visited).ToArray();
        var ignored    = stream.GetRegions(BinaryStreamRegionKind.Reading, BinaryStreamRegionType.Ignored).ToArray();
        var visitedSum = visited.Sum(s => s.Length);
        var ignoredSum = ignored.Sum(s => s.Length);
        var visitedPct = (double)visitedSum / stream.Length;
        var ignoredPct = (double)ignoredSum / stream.Length;

        return (visited, ignored, visitedSum, ignoredSum, visitedPct, ignoredPct);
    }

    private static List<(long Position, TreeNode Node)> GetNodesOrderedByPosition(TreeNode treeNode)
    {
        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        var array = treeNode.TraverseDfsPreOrder().ToArray();
        var nodes = new List<(long Position, TreeNode Node)>(array.Length);

        foreach (var node in array)
        {
            switch (node)
            {
                case DMDNode dmdNode:
                    nodes.Add((dmdNode.Position, dmdNode));
                    break;
                case DPCNode dpcNode:
                    nodes.Add((dpcNode.Position, dpcNode));
                    break;
                default:
                    throw new NotSupportedException($"Unknown node type: {node.GetType().Name}.");
            }
        }

        nodes.Sort((a, b) =>
        {
            var position1 = a.Position;
            var position2 = b.Position;
            var position  = position1.CompareTo(position2);

            if (position != default)
            {
                return position;
            }

            var name1 = a.Node.GetType().Name;
            var name2 = b.Node.GetType().Name;
            var name  = string.Compare(name1, name2, StringComparison.Ordinal);

            if (name != default)
            {
                return name;
            }

            return default;
        });

        return nodes;
    }

    private static void PrintFileInfo(TestContext context, string path)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (path == null)
            throw new ArgumentNullException(nameof(path));

        var info = new FileInfo(path);

        context.WriteLine($"File name: {info.Name}");
        context.WriteLine($"File size: {info.Length}");
        context.WriteLine();
    }

    private static void PrintStreamRegionsBrief(
        TestContext context,
        BinaryStreamRegion[] visited, double visitedPct, long visitedSum,
        BinaryStreamRegion[] ignored, double ignoredPct, long ignoredSum)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (visited == null)
            throw new ArgumentNullException(nameof(visited));

        if (ignored == null)
            throw new ArgumentNullException(nameof(ignored));

        context.WriteLine($"Regions visited: {visited.Length} regions, {visitedPct:P3}, {visitedSum:N0} bytes");
        context.WriteLine($"Regions ignored: {ignored.Length} regions, {ignoredPct:P3}, {ignoredSum:N0} bytes");
        context.WriteLine();
    }

    private static void PrintStreamRegionsDetailed(
        TestContext context, BinaryStreamRegion[] visited, BinaryStreamRegion[] ignored, List<(long Position, TreeNode Node)> list)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (visited == null)
            throw new ArgumentNullException(nameof(visited));

        if (ignored == null)
            throw new ArgumentNullException(nameof(ignored));

        if (list == null)
            throw new ArgumentNullException(nameof(list));

        context.WriteLine($"Regions visited: {visited.Length}");

        foreach (var region in visited)
        {
            context.WriteLine(region);
        }

        context.WriteLine();

        context.WriteLine($"Regions ignored: {ignored.Length}");

        foreach (var region in ignored)
        {
            var node = list.Last(s => s.Position < region.Position).Node;

            context.WriteLine($"{region}, Preceding node: {node}");
        }

        context.WriteLine();
    }

    private static void PrintTree(TestContext context, TreeNode treeNode)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        var print = treeNode.Print();

        context.WriteLine(print);
        context.WriteLine();
    }

    private static void PrintTreeDepthAndNodeCount(TestContext context, TreeNode treeNode)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        var count = 0;
        var depth = 0;

        foreach (var node in treeNode.TraverseDfsPreOrder())
        {
            count++;
            depth = Math.Max(depth, node.Depth);
        }

        context.WriteLine($"Tree depth: {depth}");
        context.WriteLine($"Tree nodes: {count}");
        context.WriteLine();
    }

    private static void PrintNodesCountByType(TestContext context, TreeNode treeNode)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        var dictionary = new SortedDictionary<Type, int>(GetTypeNameComparer());

        foreach (var node in treeNode.TraverseDfsPreOrder())
        {
            var type = node.GetType();

            dictionary.TryAdd(type, default);

            dictionary[type]++;
        }

        context.WriteLine("Node count by type:");

        foreach (var (key, value) in dictionary)
        {
            context.WriteLine($"{key.Name}: {value}");
        }

        context.WriteLine();
    }

    private static void PrintNodesByPosition(TestContext context, List<(long Position, TreeNode Node)> list)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (list == null)
            throw new ArgumentNullException(nameof(list));

        context.WriteLine($"Nodes ordered by position: {list.Count}");

        foreach (var (key, value) in list)
        {
            context.WriteLine($"{key,-6} {value.GetType().Name}");
        }

        context.WriteLine();
    }

    private static void PrintNodesRelationships(TestContext context, TreeNode treeNode)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));

        if (treeNode == null)
            throw new ArgumentNullException(nameof(treeNode));

        var comparer = GetTypeNameComparer();

        var dictionary = new SortedDictionary<Type, (SortedSet<Type> Parents, SortedSet<Type> Children)>(comparer);

        foreach (var node in treeNode.TraverseDfsPreOrder())
        {
            var type = node.GetType();

            dictionary.TryAdd(type, (new SortedSet<Type>(comparer), new SortedSet<Type>(comparer)));

            var (parents, children) = dictionary[type];

            if (node.Parent != null)
            {
                parents.Add(node.Parent.GetType());
            }

            foreach (var child in node)
            {
                children.Add(child.GetType());
            }
        }

        context.WriteLine("Nodes relationships:");

        foreach (var (key, (parents, children)) in dictionary)
        {
            context.WriteLine(key.Name);
            context.WriteLine($"\tParents: {string.Join(", ",  parents.Select(s => s.Name))}");
            context.WriteLine($"\tChildren: {string.Join(", ", children.Select(s => s.Name))}");
        }

        context.WriteLine();
    }

    private static Comparer<Type> GetTypeNameComparer()
    {
        return new DelegateComparer<Type>((x, y) =>
        {
            if (x == null && y == null)
            {
                return default;
            }

            if (x == null)
            {
                return int.MinValue;
            }

            if (y == null)
            {
                return int.MaxValue;
            }

            var compare = string.Compare(x.FullName, y.FullName, StringComparison.Ordinal);

            return compare;
        });
    }
}